%               Generalisana greska predikcije
%==========================================================================

function [teta_hat, z_novo, lambda2] = GGP(p,Z,y_hat, teta, epsilon2, duzina, omega, C2)

% Generalisana greska predikcija - pocetni uslovi i potrebne promenljive 
% Izlazni signal nakon Kalmanove predfiltracije je sada ulazni signal
y_novo = y_hat;
% Faktor skaliranja
d = median(abs(y_novo - median(y_novo)))/0.6745;
% Definisanje Z
Z_novo = Z;
for i = (p+1) : duzina
    for j = 1 : p
        Z_novo(j,i) = -y_novo(i-j,1);
    end
end

% Pocetno epsilon i teta_hat
teta_hat = teta;
epsilon_novo = epsilon2;
Ma = 5; 
for i = 1 : (Ma+1)
    epsilon_novo(i,1) = y_novo(i,1) - Z_novo(:,i)' *teta_hat(:,i);
end

% Pocetno sigma_hat
sigma_hat = 0.22*ones(duzina,1);
% Konstante za izracunavanje lambda
N_max = 500;
lambda_min = 0.75;
lambda_max = 0.998;
E = zeros(duzina,1);
omega_novo = omega; %izracunavamo zbog pocetnih vrednosti
N = zeros(duzina,1);
lambda2 = zeros(duzina,1);

% Generisana greska predikcije - algoritam
M = zeros(p,p,duzina);
K = zeros(p,1,duzina);
P = zeros(p,p,duzina);
for k = (Ma+1) : duzina
    % Definisanje greske predikcije (sa novim vrednostima)
    epsilon_novo(k,1) = y_novo(k,1) - Z_novo(:,k)' * teta_hat(:,k-1);      %(43)
    % Racunanje tezinske forme (omega_novo)
    [omega_pom_2] = omega_ggp(k,epsilon_novo, d, y_novo, Z_novo,teta_hat);
    omega_novo(k,1) = omega_pom_2;
    % Racunanje estimirane vrednosti varijanse suma
    sigma_hat(k,1) = ((k-1)* sigma_hat(k-1,1) + (epsilon_novo(k,1)^2)*omega_novo(k,1))/k;
    % Racunanje prosirene greske predikcije
    suma_1 = 0;                                                            
    for i = 1: Ma
        suma_1 = suma_1 + epsilon_novo(k-i,1)^2;
    end
    E(k,1) = suma_1/Ma;
    % Duzina memorije
    N(k,1) = ((sigma_hat(k,1)^2)*N_max) / E(k,1);                          
    % Racunanje promenljivog faktora zaboravljanja (VFF)
    lambda2(k,1) = 1-E(k,1) / (sigma_hat(k,1)*N_max);       
    % Ogranicavanje minimalne i maksimalne vrednosti VFF-a
    if lambda2(k,1) > lambda_max
        lambda2(k,1) = lambda_max;
    elseif lambda2(k,1) < lambda_min
        lambda2(k,1) = lambda_min;
    end
    M(:,:,k) = P(:,:,k-1) / lambda2(k,1);                                   
    pom_1 = M(:,:,k) * Z_novo(:,k) * omega_novo(k,1);                      
    pom_2 = 1 + Z_novo(:,k)' * pom_1;                                      
    % Matrica pojacanja
    K(:,:,k) = pom_1/pom_2;                                               
    % Pomocna konstanta
    C = C2;
    % Matrica kovarijanse greske estimacije
    P(:,:,k) = C *eye(p) - K(:,:,k)* (Z_novo(:,k)' ) * M(:,:,k);           
    % Estimirana vrednost parametara
    teta_hat(:,k) = teta_hat(:,k-1) + K(:,:,k) * epsilon_novo(k,1);   
    z_novo = y_novo;
    z_novo(k,1)=z_novo(:,k)'*teta_hat(:,k-1);
end

% % Modeliranje signala na osnovu estimiranih vrednosti parametara
% z_novo = y_novo;
% for i = (p+1) : duzina
%     z_novo(i,1) = 0;
%     for k = 1 : p
%         z_novo(i,1) = z_novo(i,1) - teta_hat(k,i)* z_novo(i-k,1);
%         
%     end
%end

end